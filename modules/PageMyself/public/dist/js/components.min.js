'use strict';

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

class PageMyselfComponent {
  /**
   * Instances
   * @type {Object<string, PageMyselfComponent>}
   */

  /**
   * Additional color map for tinymce to list theme colors as well
   * @type {string[]}
   */

  /**
   * The block id
   * @type {number}
   */

  /**
   * The block container
   * @type {Cash}
   */

  /**
   * The tinymce editor instance, if enableTextEditor has been called
   */

  /**
   * Constructor
   * @param {number} id
   */
  constructor(id) {
    _defineProperty(this, "id", void 0);

    _defineProperty(this, "container", void 0);

    _defineProperty(this, "editor", void 0);

    PageMyselfComponent.instances[id] = this;
    this.id = id;
    this.container = $('.component-block').filter('[data-id=\'' + id + '\']');
  }
  /**
   * Initialize the block
   * @param {Object|Array=} params Parameters passed from the backend
   * @returns {Promise<void>}
   */


  async init(params) {}
  /**
   * Disable editing of this block
   * @returns {Promise<void>}
   */


  async disableEditing() {
    this.container.attr('data-editing', '0');
    if (this.editor) this.editor.destroy();
  }
  /**
   * Enable editing of this block
   * @returns {Promise<void>}
   */


  async enableEditing() {
    this.container.attr('data-editing', '1');
  }
  /**
   * Enable live text editor on given container
   * @param {Cash} container
   * @returns {Promise<void>}
   */


  async enableTextEditor(container) {
    if (!container.attr('data-id')) {
      console.error('The container needs a data-id attribute in order to save text attached to this container', container);
      return;
    }

    const self = this;
    await FramelixDom.includeResource(window.top.eval('PageMyselfPageEditor.config.tinymceUrl'), 'tinymce');
    await FramelixDom.includeResource(window.top.eval('PageMyselfPageEditor.config.tinymcePluginsUrl'), function () {
      return !!(tinymce && tinymce.PluginManager.get('pagemyself'));
    });
    let fontSizes = [];

    for (let i = 0.6; i <= 8; i += 0.2) {
      fontSizes.push(i.toFixed(1) + 'rem');
    }

    let font_formats = '';
    const fonts = {
      'Andale Mono': {
        'name': 'andale mono,times,sans-serif'
      },
      'Arial': {
        'name': 'arial,helvetica,sans-serif'
      },
      'Arial Black': {
        'name': 'arial black,avant garde,sans-serif'
      },
      'Book Antiqua': {
        'name': 'book antiqua,palatino,sans-serif'
      },
      'Comic Sans MS': {
        'name': 'comic sans ms,sans-serif'
      },
      'Courier New': {
        'name': 'courier new,courier,sans-serif'
      },
      'Georgia': {
        'name': 'georgia,palatino,sans-serif'
      },
      'Helvetica': {
        'name': 'helvetica,sans-serif'
      },
      'Impact': {
        'name': 'impact,chicago,sans-serif'
      },
      'Symbol': {
        'name': 'symbol,sans-serif'
      },
      'Tahoma': {
        'name': 'tahoma,arial,helvetica,sans-serif'
      },
      'Terminal': {
        'name': 'terminal,monaco,sans-serif'
      },
      'Times New Roman': {
        'name': 'times new roman,times,sans-serif'
      },
      'Trebuchet MS': {
        'name': 'trebuchet ms,geneva,sans-serif'
      },
      'Verdana': {
        'name': 'verdana,geneva,sans-serif'
      },
      'Webdings': {
        'name': 'webdings'
      },
      'Wingdings': {
        'name': 'wingdings,zapf dingbats'
      }
    };

    for (let key in fonts) {
      const row = fonts[key];
      font_formats += key + '=' + row.name + ';';
    }

    let colorMap = PageMyselfComponent.additionalColorMap.concat(['#bfedd2', 'Light Green', '#fbeeb8', 'Light Yellow', '#f8cac6', 'Light Red', '#eccafa', 'Light Purple', '#c2e0f4', 'Light Blue', '#2dc26b', 'Green', '#f1c40f', 'Yellow', '#e03e2d', 'Red', '#b96ad9', 'Purple', '#3598db', 'Blue', '#169179', 'Dark Turquoise', '#e67e23', 'Orange', '#ba372a', 'Dark Red', '#843fa1', 'Dark Purple', '#236fa1', 'Dark Blue', '#ecf0f1', 'Light Gray', '#ced4d9', 'Medium Gray', '#95a5a6', 'Gray', '#7e8c8d', 'Dark Gray', '#34495e', 'Navy Blue', '#000', 'Black', '#fff', 'White']);
    tinymce.init({
      'font_formats': font_formats,
      font_size_formats: fontSizes.join(' '),
      language: ['en', 'de'].indexOf(FramelixLang.lang) > -1 ? FramelixLang.lang : 'en',
      target: container[0],
      menubar: false,
      inline: true,
      valid_elements: '*[*]',
      color_map: colorMap,
      plugins: ['image', 'link', 'media', 'table', 'advlist', 'lists', 'code', '-pagemyself'],
      file_picker_callback: async function file_picker_callback(callback, value, meta) {
        const modal = await self.apiRequestInModal('textEditorMediaBrowser');
        modal.bodyContainer.on('change', '.mediabrowser-file[data-url]', function () {
          const checked = $(this).find('input:checked');

          if (checked.length) {
            callback($(this).attr('data-url'));
            modal.destroy();
          }
        });
      },
      toolbar: 'pagemyself-save-text pagemyself-templates | bold italic underline strikethrough | pagemyself-cancel-text | fontfamily fontsize lineheight | alignleft aligncenter alignright alignjustify | image media pageembed link | forecolor backcolor removeformat | outdent indent | numlist bullist checklist | table  | code',
      powerpaste_word_import: 'clean',
      powerpaste_html_import: 'clean',
      image_dimensions: false,
      setup: function setup(instance) {
        instance.pagemyselfComponent = self;
        self.editor = instance;
        instance.on('init', function (e) {
          instance.initialContent = instance.getContent();
        });
      }
    });
  }
  /**
   * Make an api request
   * @param {string} action
   * @param {Object=} params
   * @returns {Promise<any>}
   */


  async apiRequest(action, params) {
    const pageMyself = window.top.eval('PageMyself');
    return FramelixApi.callPhpMethod(pageMyself.config.componentApiRequestUrl, {
      'action': action,
      'componentBlockId': this.id,
      'params': params
    });
  }
  /**
   * Make an api request and display result in modal window
   * @param {string} action
   * @param {Object=} params
   * @returns {Promise<FramelixModal>}
   */


  async apiRequestInModal(action, params) {
    const modal = window.top.eval('FramelixModal');
    const pageMyself = window.top.eval('PageMyself');
    return modal.callPhpMethod(pageMyself.config.componentApiRequestUrl, {
      'action': action,
      'componentBlockId': this.id,
      'params': params
    }, {
      maxWidth: 900
    });
  }

}

_defineProperty(PageMyselfComponent, "instances", {});

_defineProperty(PageMyselfComponent, "additionalColorMap", []);

class PageMyselfComponentCalendar extends PageMyselfComponent {
  /**
   * Disable editing of this block
   * @returns {Promise<void>}
   */
  async disableEditing() {
    await super.disableEditing();
    this.container.off('click', 'td[data-date]');
  }
  /**
   * Enable editing of this block
   * @returns {Promise<void>}
   */


  async enableEditing() {
    await super.enableEditing();
    const self = this;
    this.container.on('click', 'td[data-date]', function (ev) {
      self.apiRequestInModal('dateInfo', {
        'date': $(this).attr('data-date')
      });
    });
  }
  /**
   * Initialize the block
   * @param {Object=} params Parameters passed from the backend
   * @returns {Promise<void>}
   */


  async init(params) {
    await super.init();
    const tableContainer = this.container.find('.calendar-table');
    const self = this;
    this.container.on('click', '.calendar-month-select [data-action="gettable"]', async function (ev) {
      ev.preventDefault();
      tableContainer.toggleClass('framelix-pulse', true);
      window.history.pushState(null, null, this.href);
      const result = await self.apiRequest('getTable', {
        'date': $(this).attr('data-date')
      });
      tableContainer.toggleClass('framelix-pulse', false);
      tableContainer.html(result);
    });
  }

}

class PageMyselfComponentSlideshow extends PageMyselfComponent {
  constructor(...args) {
    super(...args);

    _defineProperty(this, "index", 0);

    _defineProperty(this, "images", []);

    _defineProperty(this, "imageContainer", void 0);
  }

  /**
   * Initialize the block
   * @param {Object|Array=} params Parameters passed from the backend
   * @returns {Promise<void>}
   */
  async init(params) {
    const self = this;
    this.imageContainer = this.container.find('.slideshow-image');
    this.images = params.images;

    if (!this.images.length) {
      return;
    }

    this.gotoImage(this.index);
    const thumbsContainer = self.container.find('.slideshow-thumbs');

    if (params.thumbnails) {
      FramelixIntersectionObserver.onGetVisible(this.imageContainer, function () {
        // implement thumbs
        for (let i = 0; i < self.images.length; i++) {
          const row = self.images[i];
          thumbsContainer.append('<div data-index="' + i + '" class="' + (i === self.index ? 'slideshow-thumb-active' : '') + '" data-id="' + row.id + '"><div data-background-image="' + row.url + '"></div></div>');
        }
      });
    } else {
      thumbsContainer.remove();
    }

    this.container.on('click', '.slideshow-btn', function () {
      self.gotoImage(self.index + parseInt($(this).attr('data-dir')));
    });
    this.imageContainer.on('click', '.slideshow-image-inner[data-background-image-original]', function () {
      window.open($(this).attr('data-background-image-original'));
    }); // on any swipe left/right we close as well

    this.imageContainer.on('swiped-left', function () {
      self.gotoImage(self.index + 1);
    });
    this.imageContainer.on('swiped-right', function () {
      self.gotoImage(self.index - 1);
    });
    this.container.on('click', '.slideshow-thumbs > div', function () {
      self.gotoImage(parseInt($(this).attr('data-index')));
    });
  }
  /**
   * Goto image
   * @param {number} index
   */


  gotoImage(index) {
    const row = this.images[this.getFixedIndex(index)];
    const rowPrev = this.images[this.getFixedIndex(index - 1)];
    const rowNext = this.images[this.getFixedIndex(index + 1)];
    this.index = this.getFixedIndex(index);
    const thumbsContainer = this.container.find('.slideshow-thumbs');
    const activeImage = thumbsContainer.find('[data-index]').removeClass('slideshow-thumb-active').filter('[data-index="' + this.index + '"]').addClass('slideshow-thumb-active');

    if (activeImage.length) {
      try {
        activeImage[0].scrollIntoView({
          inline: 'center',
          'block': 'nearest'
        });
      } catch (e) {}
    }

    this.imageContainer.empty();
    this.imageContainer.append(`<div class="slideshow-image-inner" data-visible="1"><div class="framelix-loading"></div></div>`);
    this.imageContainer.append(`<div class="slideshow-image-inner" data-background-image="${row.url}"></div>`);
    this.imageContainer.append(`<div class="slideshow-image-inner" data-background-image="${rowPrev.url}"></div>`);
    this.imageContainer.append(`<div class="slideshow-image-inner" data-background-image="${rowNext.url}"></div>`);
    this.imageContainer.append(`<div class="slideshow-image-inner" data-background-image="${row.url}" data-visible="1"></div>`);
  }
  /**
   * Get existing index if given index is out or range
   * @param {number} index
   * @returns {number}
   */


  getFixedIndex(index) {
    if (index < 0) index = this.images.length - 1;
    if (index >= this.images.length) index = 0;
    return index;
  }
  /**
   * Enable editing of this block
   * @returns {Promise<void>}
   */


  async enableEditing() {
    await super.enableEditing();
    const self = this;
    const thumbsContainer = this.container.find('.slideshow-thumbs');

    if (!this.images.length) {
      this.container.find('.slideshow-image').html('<div class="slideshow-image-inner" data-visible="1"><button class="framelix-button open-block-settings">' + FramelixLang.get('__pagemyself_component_open_settings__') + '</button></div>');
    } else {
      if (thumbsContainer.length) {
        FramelixDom.includeCompiledFile('Framelix', 'js', 'sortablejs', 'Sortable').then(function () {
          new Sortable(thumbsContainer[0], {
            'onSort': function onSort() {
              const ids = [];
              thumbsContainer.find('[data-id]').each(function () {
                ids.push($(this).attr('data-id'));
              });
              self.apiRequest('sort', {
                'ids': ids
              });
            }
          });
        });
      }
    }
  }

}

class PageMyselfComponentText extends PageMyselfComponent {
  /**
   * Enable editing of this block
   * @returns {Promise<void>}
   */
  async enableEditing() {
    await super.enableEditing();
    this.enableTextEditor(this.container.find('.pagemyself-component-text-text'));
  }

}